"""
This module provides a simple interface to provide text features
and receive Intent and Entities.
"""
from typing import Any, List, Dict, Optional

import attr

[% if use_ner %]
from dialogy.postprocess.text.slot_filler.rule_slot_filler import (
    RuleBasedSlotFillerPlugin,
)
[% endif %]
[% if intent_classification_flavor == 2 %]
from dialogy.postprocess.text.voting.intent import VotePlugin
[% endif %]
[% if intent_classification_flavor == 1 %]
from dialogy.preprocess.text.merge_asr_output import merge_asr_output_plugin
[% endif %]
[% if use_duckling %]
from dialogy.parser.text.entity.duckling_parser import DucklingParser
[% endif %]

from [[python_package_import_name]] import constants as const
from [[python_package_import_name]].utils.config import Config
from [[python_package_import_name]].src.workflow.workflow import XLMRWorkflow

config = Config()

[% if use_ner or use_duckling %]
slot_filler = RuleBasedSlotFillerPlugin(
    rules=config.rules[const.SLOTS], access=lambda w: w.output
)()
[% endif %]

[% if intent_classification_flavor == 2 %]
def update_intent(workflow, value):
    _, entities = workflow.output
    workflow.output = (value, entities)

vote_plugin = VotePlugin(
    fallback_intent=const.S_INTENT_OOS,
    access=lambda w: w.output[0],
    mutate=update_intent,
)()
[% else %]
def update_input(w: XLMRWorkflow, value: str) -> None:
    w.input[const.S_CLASSIFICATION_INPUT] = value

merge_asr_output = merge_asr_output_plugin(access=lambda w: w.input[const.S_CLASSIFICATION_INPUT], mutate=update_input)
[% endif %]

[% if use_duckling %]
def update_entities(workflow, entities):
    workflow.output = (None, entities)

duckling_parser = DucklingParser(access=lambda w: (w.input[const.S_CLASSIFICATION_INPUT], w.input[const.S_REFERENCE_TIME]), 
    mutate=update_entities, 
    dimensions=["number"], 
    locale="en_IN")()
[% endif %]


def predict_wrapper():
    """
    Create a closure for the predict function.

    Ensures that the workflow is loaded just once without creating global variables for it.
    This can also be made into a class if needed.
    """
    preprocessors = []
    postprocessors = []

    [% if intent_classification_flavor == 2 %]
    postprocessors.append(vote_plugin)
    [% else %]
    preprocessors.append(merge_asr_output)
    [% endif %]
    [% if use_duckling %]
    preprocessors.append(duckling_parser)
    [% endif %]

    [# This should always be last #]
    [% if use_ner or use_duckling %]
    postprocessors.append(slot_filler)
    [% endif %]

    workflow = XLMRWorkflow(
        preprocessors=preprocessors,
        postprocessors=postprocessors,
    )
    def predict(utterance: List[str], context: Dict[str, Any], reference_time: Optional[int] = None):
        """
        Produce intent and entities for a given utterance.

        The second argument is context. Use it when available, it is
        a good practice to use it for modeling.
        """
        [% if intent_classification_flavor == 1 %]
        intent, entities = workflow.run({const.S_CLASSIFICATION_INPUT: utterance, const.S_NER_INPUT: utterance, const.S_REFERENCE_TIME: reference_time})
        [% else %]
        intent, entities = workflow.run({const.S_CLASSIFICATION_INPUT: utterance, const.S_REFERENCE_TIME: reference_time})
        [% endif %]

        intent = attr.asdict(intent)

        [% if use_ner or use_duckling %]
        slots = []

        for slot_name, slot_values in intent[const.SLOTS].items():
            slot_values[const.NAME] = slot_name
            slots.append(slot_values)

        intent[const.SLOTS] = slots
        [% endif %]

        return {
            const.VERSION: config.version,
            const.INTENTS: [intent],
            const.ENTITIES: [attr.asdict(entity) for entity in entities],
        }

    return predict
